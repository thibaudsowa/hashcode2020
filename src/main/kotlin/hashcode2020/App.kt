/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package hashcode2020

import java.io.File
import java.util.*

fun main(args: Array<String>) {
    println("Hello HashCode 2020!")

    val fileInput = ArrayList<String>()
    fileInput.add("a_example.txt")
    fileInput.add("b_read_on.txt")
    fileInput.add("c_incunabula.txt")
    fileInput.add("d_tough_choices.txt")
    fileInput.add("e_so_many_books.txt")
    fileInput.add("f_libraries_of_the_world.txt")

    fileInput.parallelStream().forEach { it ->
        println("$it");

        var librairieResult = arrayListOf<Librairie>()
        var scores = arrayListOf<Int>()

        val lines = ArrayList<String>()
        File("inputs/" + it).forEachLine { lines.add(it) }
        val template = HashCodeTemplate(lines)
        val data = BookProblemData(template)

        leCerveau(data, librairieResult)
        val librairie = data.librairies.get(0)
        val reponse = HashCodeReponse(Arrays.asList(librairieResult.size), serializeLibrairies(librairieResult))
        reponse.toFile("outputs/" + it)


    }
    println("C'est fini!")

}

private fun leCerveau(data: BookProblemData, resultLibrairies: MutableList<Librairie>) {
    var listBouquinScanned = mutableListOf<Int>();
    data.librairies.sortBy { librairie -> librairie.nbJourRegister }
    data.librairies.forEach { librairie: Librairie ->
        librairie.books.sortedBy { idbook: Int -> data.bookScores[idbook] }
        librairie.books.filter { idBooks -> !listBouquinScanned.contains(idBooks) }.forEach { idBooks: Int ->
            librairie.selectBook(idBooks)
            listBouquinScanned.add(idBooks)
            if (librairie.selectedBook.isNotEmpty()) {
                resultLibrairies.add(librairie)
            }
        }
    }
}

fun calculScore(bookProblemData: BookProblemData, librairie: Librairie): Int {
    var somme = 0
    for (i in 0 until librairie.nbBook) {
        somme = librairie.books[i] * hasLivre(bookProblemData, librairie.books[i])

    }
    return somme / getTime(bookProblemData, librairie)
}

fun hasLivre(bookProblemData: BookProblemData, idLivre: Int): Int {
    if (bookProblemData.livreScanned.contains(idLivre)) {
        return 0
    } else {
        return 1
    }
}

fun getTime(bookProblemData: BookProblemData, librairie: Librairie): Int {
    return calculateNbBooksNotAlreadyRead(bookProblemData, librairie) * librairie.nbBookDay + librairie.nbJourRegister
}

fun calculateNbBooksNotAlreadyRead(bookProblemData: BookProblemData, librairie: Librairie): Int {
    var somme = 0
    for (i in 0 until librairie.nbBook) {
        somme += hasLivre(bookProblemData, librairie.books[i])
    }
    return somme
}

fun serializeLibrairies(librairies: List<Librairie>): List<List<String>> {
    return librairies.map { librairie -> librairie.serialize() }.filter { list -> !list.isEmpty() }.flatMap { list -> list }
}